/* This file was generated by plugin 'Nordic Semiconductor nRF5x v.1.2.2' (BDS version 1.1.3139.0) */

#include "ble_peggy_peripheral.h"
#include <string.h>
#include "nordic_common.h"
#include "ble_srv_common.h"
#include "app_util.h"
#include "app_util_bds.h"

#define OPCODE_LENGTH 1 /**< Length of opcode inside Peggy peripheral packet. */
#define HANDLE_LENGTH 2 /**< Length of handle inside Peggy peripheral packet. */

/* TODO Consider changing the max values if encoded data for characteristic/descriptor is fixed length */ 
#define MAX_COIN_EVENT_NOTIFICATION_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Coin Event Notification. */ 
#define MAX_PENDING_TRANSACTIONS_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Pending Transactions. */ 
#define MAX_PENDING_TRANSACTIONS_INDICATOR_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Pending Transactions Indicator. */ 
#define MAX_UUID_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted UUID. */ 
#define MAX_ERASE_BONDING_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Erase Bonding. */ 
#define MAX_USER_INFORMATION_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted User Information. */ 

/**@brief Function for encoding Coin Event Notification.
 *
 * @param[in]   p_coin_event_notification              Coin Event Notification characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t coin_event_notification_encode(ble_peggy_peripheral_coin_event_notification_t * p_coin_event_notification, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_coin_event_notification->new_coin;
    return len;
}

/**@brief Function for encoding Pending Transactions.
 *
 * @param[in]   p_pending_transactions              Pending Transactions characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t pending_transactions_encode(ble_peggy_peripheral_pending_transactions_t * p_pending_transactions, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_pending_transactions->ones;
    encoded_buffer[len++] = p_pending_transactions->fiftys;
    encoded_buffer[len++] = p_pending_transactions->twenties;
    encoded_buffer[len++] = p_pending_transactions->tens;
    encoded_buffer[len++] = p_pending_transactions->fives;
    encoded_buffer[len++] = p_pending_transactions->twos;
    len += bds_uint32_encode(&p_pending_transactions->seconds, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for encoding Pending Transactions Indicator.
 *
 * @param[in]   p_pending_transactions_indicator              Pending Transactions Indicator characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t pending_transactions_indicator_encode(ble_peggy_peripheral_pending_transactions_indicator_t * p_pending_transactions_indicator, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_pending_transactions_indicator->pending_transactions;
    return len;
}

/**@brief Function for encoding UUID.
 *
 * @param[in]   p_uuid              UUID characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t uuid_encode(ble_peggy_peripheral_uuid_t * p_uuid, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += bds_uint32_encode(&p_uuid->field1, &encoded_buffer[len]); 
    len += bds_uint32_encode(&p_uuid->field2, &encoded_buffer[len]); 
    len += bds_uint32_encode(&p_uuid->field3, &encoded_buffer[len]); 
    len += bds_uint32_encode(&p_uuid->field4, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for decoding UUID.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t uuid_decode(uint8_t data_len, uint8_t * p_data, ble_peggy_peripheral_uuid_t * p_write_val)
{
    uint8_t pos = 0;
    pos += bds_uint32_decode((data_len-pos), &p_data[pos], &p_write_val->field1); 
    pos += bds_uint32_decode((data_len-pos), &p_data[pos], &p_write_val->field2); 
    pos += bds_uint32_decode((data_len-pos), &p_data[pos], &p_write_val->field3); 
    pos += bds_uint32_decode((data_len-pos), &p_data[pos], &p_write_val->field4); 

    return pos;
} 
/**@brief Function for encoding Erase Bonding.
 *
 * @param[in]   p_erase_bonding              Erase Bonding characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t erase_bonding_encode(ble_peggy_peripheral_erase_bonding_t * p_erase_bonding, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_erase_bonding->killcode;
    return len;
}

/**@brief Function for decoding Erase Bonding.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t erase_bonding_decode(uint8_t data_len, uint8_t * p_data, ble_peggy_peripheral_erase_bonding_t * p_write_val)
{
    uint8_t pos = 0;
    p_write_val->killcode = p_data[pos++]; 

    return pos;
} 
/**@brief Function for encoding User Information.
 *
 * @param[in]   p_user_information              User Information characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t user_information_encode(ble_peggy_peripheral_user_information_t * p_user_information, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_user_information->balance_ok;
    encoded_buffer[len++] = p_user_information->user;
    return len;
}

/**@brief Function for decoding User Information.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t user_information_decode(uint8_t data_len, uint8_t * p_data, ble_peggy_peripheral_user_information_t * p_write_val)
{
    uint8_t pos = 0;
    p_write_val->balance_ok = p_data[pos++]; 
    p_write_val->user = p_data[pos++]; 

    return pos;
} 

/**@brief Function for handling the Connect event.
 *
 * @param[in]   p_peggy_peripheral       Peggy peripheral Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_connect(ble_peggy_peripheral_t * p_peggy_peripheral, ble_evt_t * p_ble_evt)
{
    p_peggy_peripheral->conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
}

/**@brief Function for handling the Disconnect event.
 *
 * @param[in]   p_peggy_peripheral       Peggy peripheral Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_disconnect(ble_peggy_peripheral_t * p_peggy_peripheral, ble_evt_t * p_ble_evt)
{
    UNUSED_PARAMETER(p_ble_evt);
    p_peggy_peripheral->conn_handle = BLE_CONN_HANDLE_INVALID;
}

/**@brief Function for handling the Write event.
 *
 * @param[in]   p_peggy_peripheral       Peggy peripheral Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_write(ble_peggy_peripheral_t * p_peggy_peripheral, ble_gatts_evt_write_t * p_ble_evt)
{
    
    if(p_ble_evt->handle == p_peggy_peripheral->coin_event_notification_handles.cccd_handle)
    {
        if(p_peggy_peripheral->evt_handler != NULL)
        {
            ble_peggy_peripheral_evt_t evt;
            evt.evt_type = BLE_PEGGY_PERIPHERAL_COIN_EVENT_NOTIFICATION_EVT_CCCD_WRITE;
            bds_uint16_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.cccd_value);
            p_peggy_peripheral->evt_handler(p_peggy_peripheral, &evt);
        }
    } 
    if(p_ble_evt->handle == p_peggy_peripheral->pending_transactions_indicator_handles.cccd_handle)
    {
        if(p_peggy_peripheral->evt_handler != NULL)
        {
            ble_peggy_peripheral_evt_t evt;
            evt.evt_type = BLE_PEGGY_PERIPHERAL_PENDING_TRANSACTIONS_INDICATOR_EVT_CCCD_WRITE;
            bds_uint16_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.cccd_value);
            p_peggy_peripheral->evt_handler(p_peggy_peripheral, &evt);
        }
    } 
    if(p_ble_evt->handle == p_peggy_peripheral->uuid_handles.value_handle)
    {
        if(p_peggy_peripheral->evt_handler != NULL)
        {
            ble_peggy_peripheral_evt_t evt;
            evt.evt_type = BLE_PEGGY_PERIPHERAL_UUID_EVT_WRITE;
            uuid_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.uuid);
            p_peggy_peripheral->evt_handler(p_peggy_peripheral, &evt);
        }
    }
    if(p_ble_evt->handle == p_peggy_peripheral->erase_bonding_handles.value_handle)
    {
        if(p_peggy_peripheral->evt_handler != NULL)
        {
            ble_peggy_peripheral_evt_t evt;
            evt.evt_type = BLE_PEGGY_PERIPHERAL_ERASE_BONDING_EVT_WRITE;
            erase_bonding_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.erase_bonding);
            p_peggy_peripheral->evt_handler(p_peggy_peripheral, &evt);
        }
    }
    if(p_ble_evt->handle == p_peggy_peripheral->user_information_handles.value_handle)
    {
        if(p_peggy_peripheral->evt_handler != NULL)
        {
            ble_peggy_peripheral_evt_t evt;
            evt.evt_type = BLE_PEGGY_PERIPHERAL_USER_INFORMATION_EVT_WRITE;
            user_information_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.user_information);
            p_peggy_peripheral->evt_handler(p_peggy_peripheral, &evt);
        }
    }
}

/**@brief Authorize WRITE request event handler.
 *
 * @details Handles WRITE events from the BLE stack.
 *
 * @param[in]   p_sc_ctrlpt  SC Ctrlpt structure.
 * @param[in]   p_gatts_evt  GATTS Event received from the BLE stack.
 *
 */
static void on_rw_authorize_request(ble_peggy_peripheral_t * p_peggy_peripheral, ble_gatts_evt_t * p_gatts_evt)
{
    ble_gatts_evt_rw_authorize_request_t * p_auth_req = &p_gatts_evt->params.authorize_request;
    if (p_auth_req->type == BLE_GATTS_AUTHORIZE_TYPE_WRITE)
    {
        if (   (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_PREP_WRITE_REQ)
            && (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_EXEC_WRITE_REQ_NOW)
            && (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL)
           )
        {
        
            if (p_auth_req->request.write.handle == p_peggy_peripheral->uuid_handles.value_handle)
            {
                on_write(p_peggy_peripheral, &p_auth_req->request.write);
            }
            if (p_auth_req->request.write.handle == p_peggy_peripheral->erase_bonding_handles.value_handle)
            {
                on_write(p_peggy_peripheral, &p_auth_req->request.write);
            }
            if (p_auth_req->request.write.handle == p_peggy_peripheral->user_information_handles.value_handle)
            {
                on_write(p_peggy_peripheral, &p_auth_req->request.write);
            }
        }
    }
}

/**@brief Function for handling BLE events.
 *
 * @param[in]   p_peggy_peripheral       Peggy peripheral Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
void ble_peggy_peripheral_on_ble_evt(ble_peggy_peripheral_t * p_peggy_peripheral, ble_evt_t * p_ble_evt)
{
    switch (p_ble_evt->header.evt_id)
    {
        case BLE_GAP_EVT_CONNECTED:
            on_connect(p_peggy_peripheral, p_ble_evt);
            break;
        case BLE_GAP_EVT_DISCONNECTED:
            on_disconnect(p_peggy_peripheral, p_ble_evt);
            break;
        case BLE_GATTS_EVT_WRITE:
            on_write(p_peggy_peripheral, &p_ble_evt->evt.gatts_evt.params.write);
            break;
         case BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST:
            on_rw_authorize_request(p_peggy_peripheral, &p_ble_evt->evt.gatts_evt);
            break;
        default:
            //No implementation needed.
            break;
    }
}

/**@brief Function for initializing the Peggy peripheral. */
uint32_t ble_peggy_peripheral_init(ble_peggy_peripheral_t * p_peggy_peripheral, const ble_peggy_peripheral_init_t * p_peggy_peripheral_init)
{
    uint32_t err_code;
    ble_uuid_t ble_uuid;

    // Initialize service structure
    p_peggy_peripheral->evt_handler = p_peggy_peripheral_init->evt_handler;
    p_peggy_peripheral->conn_handle = BLE_CONN_HANDLE_INVALID;
    
    // Add a custom base UUID.
    ble_uuid128_t bds_base_uuid = {{0x63, 0x62, 0x89, 0xCD, 0xD6, 0xA0, 0xAE, 0xAE, 0x78, 0x41, 0x8E, 0xEE, 0x00, 0x00, 0xBE, 0xDE}};
    uint8_t       uuid_type;
    err_code = sd_ble_uuid_vs_add(&bds_base_uuid, &uuid_type);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }
    ble_uuid.type = uuid_type;
    ble_uuid.uuid = 0x2900;
        
    // Add service
    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_peggy_peripheral->service_handle);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Coin Event Notification characteristic
    ble_peggy_peripheral_coin_event_notification_t coin_event_notification_initial_value = p_peggy_peripheral_init->ble_peggy_peripheral_coin_event_notification_initial_value; 

    uint8_t coin_event_notification_encoded_value[MAX_COIN_EVENT_NOTIFICATION_LEN];
    ble_add_char_params_t add_coin_event_notification_params;
    memset(&add_coin_event_notification_params, 0, sizeof(add_coin_event_notification_params));
    
    add_coin_event_notification_params.uuid                = 0x2901;
    add_coin_event_notification_params.uuid_type           = ble_uuid.type; 
    add_coin_event_notification_params.max_len             = MAX_COIN_EVENT_NOTIFICATION_LEN;
    add_coin_event_notification_params.init_len            = coin_event_notification_encode(&coin_event_notification_initial_value, coin_event_notification_encoded_value);
    add_coin_event_notification_params.p_init_value        = coin_event_notification_encoded_value; 
    add_coin_event_notification_params.char_props.notify   = 1; 
    add_coin_event_notification_params.cccd_write_access   = SEC_OPEN;
    // 1 for variable length and 0 for fixed length.
    add_coin_event_notification_params.is_var_len          = 1; 

    err_code = characteristic_add(p_peggy_peripheral->service_handle, &add_coin_event_notification_params, &(p_peggy_peripheral->coin_event_notification_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Pending Transactions characteristic
    ble_peggy_peripheral_pending_transactions_t pending_transactions_initial_value = p_peggy_peripheral_init->ble_peggy_peripheral_pending_transactions_initial_value; 
    p_peggy_peripheral->is_pending_transactions_read_supported = p_peggy_peripheral_init->is_pending_transactions_read_supported;

    uint8_t pending_transactions_encoded_value[MAX_PENDING_TRANSACTIONS_LEN];
    ble_add_char_params_t add_pending_transactions_params;
    memset(&add_pending_transactions_params, 0, sizeof(add_pending_transactions_params));
    
    add_pending_transactions_params.uuid                = 0x2903;
    add_pending_transactions_params.uuid_type           = ble_uuid.type; 
    add_pending_transactions_params.max_len             = MAX_PENDING_TRANSACTIONS_LEN;
    add_pending_transactions_params.init_len            = pending_transactions_encode(&pending_transactions_initial_value, pending_transactions_encoded_value);
    add_pending_transactions_params.p_init_value        = pending_transactions_encoded_value; 
    add_pending_transactions_params.char_props.read = p_peggy_peripheral->is_pending_transactions_read_supported; 
    add_pending_transactions_params.read_access         = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_pending_transactions_params.is_var_len          = 1; 

    err_code = characteristic_add(p_peggy_peripheral->service_handle, &add_pending_transactions_params, &(p_peggy_peripheral->pending_transactions_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Pending Transactions Indicator characteristic
    ble_peggy_peripheral_pending_transactions_indicator_t pending_transactions_indicator_initial_value = p_peggy_peripheral_init->ble_peggy_peripheral_pending_transactions_indicator_initial_value; 

    uint8_t pending_transactions_indicator_encoded_value[MAX_PENDING_TRANSACTIONS_INDICATOR_LEN];
    ble_add_char_params_t add_pending_transactions_indicator_params;
    memset(&add_pending_transactions_indicator_params, 0, sizeof(add_pending_transactions_indicator_params));
    
    add_pending_transactions_indicator_params.uuid                = 0x2902;
    add_pending_transactions_indicator_params.uuid_type           = ble_uuid.type; 
    add_pending_transactions_indicator_params.max_len             = MAX_PENDING_TRANSACTIONS_INDICATOR_LEN;
    add_pending_transactions_indicator_params.init_len            = pending_transactions_indicator_encode(&pending_transactions_indicator_initial_value, pending_transactions_indicator_encoded_value);
    add_pending_transactions_indicator_params.p_init_value        = pending_transactions_indicator_encoded_value; 
    add_pending_transactions_indicator_params.char_props.indicate = 1; 
    add_pending_transactions_indicator_params.cccd_write_access   = SEC_OPEN;
    // 1 for variable length and 0 for fixed length.
    add_pending_transactions_indicator_params.is_var_len          = 1; 

    err_code = characteristic_add(p_peggy_peripheral->service_handle, &add_pending_transactions_indicator_params, &(p_peggy_peripheral->pending_transactions_indicator_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add UUID characteristic
    ble_peggy_peripheral_uuid_t uuid_initial_value = p_peggy_peripheral_init->ble_peggy_peripheral_uuid_initial_value; 
    p_peggy_peripheral->is_uuid_read_supported = p_peggy_peripheral_init->is_uuid_read_supported;
    p_peggy_peripheral->is_uuid_write_supported = p_peggy_peripheral_init->is_uuid_write_supported;

    uint8_t uuid_encoded_value[MAX_UUID_LEN];
    ble_add_char_params_t add_uuid_params;
    memset(&add_uuid_params, 0, sizeof(add_uuid_params));
    
    add_uuid_params.uuid                = 0x2904;
    add_uuid_params.uuid_type           = ble_uuid.type; 
    add_uuid_params.max_len             = MAX_UUID_LEN;
    add_uuid_params.init_len            = uuid_encode(&uuid_initial_value, uuid_encoded_value);
    add_uuid_params.p_init_value        = uuid_encoded_value; 
    add_uuid_params.char_props.read = p_peggy_peripheral->is_uuid_read_supported; 
    add_uuid_params.read_access         = SEC_OPEN; 
    add_uuid_params.char_props.write = p_peggy_peripheral->is_uuid_write_supported; 
    add_uuid_params.write_access        = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_uuid_params.is_var_len          = 1; 

    err_code = characteristic_add(p_peggy_peripheral->service_handle, &add_uuid_params, &(p_peggy_peripheral->uuid_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Erase Bonding characteristic
    ble_peggy_peripheral_erase_bonding_t erase_bonding_initial_value = p_peggy_peripheral_init->ble_peggy_peripheral_erase_bonding_initial_value; 
    p_peggy_peripheral->is_erase_bonding_write_supported = p_peggy_peripheral_init->is_erase_bonding_write_supported;

    uint8_t erase_bonding_encoded_value[MAX_ERASE_BONDING_LEN];
    ble_add_char_params_t add_erase_bonding_params;
    memset(&add_erase_bonding_params, 0, sizeof(add_erase_bonding_params));
    
    add_erase_bonding_params.uuid                = 0x2905;
    add_erase_bonding_params.uuid_type           = ble_uuid.type; 
    add_erase_bonding_params.max_len             = MAX_ERASE_BONDING_LEN;
    add_erase_bonding_params.init_len            = erase_bonding_encode(&erase_bonding_initial_value, erase_bonding_encoded_value);
    add_erase_bonding_params.p_init_value        = erase_bonding_encoded_value; 
    add_erase_bonding_params.char_props.write = p_peggy_peripheral->is_erase_bonding_write_supported; 
    add_erase_bonding_params.write_access        = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_erase_bonding_params.is_var_len          = 1; 

    err_code = characteristic_add(p_peggy_peripheral->service_handle, &add_erase_bonding_params, &(p_peggy_peripheral->erase_bonding_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add User Information characteristic
    ble_peggy_peripheral_user_information_t user_information_initial_value = p_peggy_peripheral_init->ble_peggy_peripheral_user_information_initial_value; 

    uint8_t user_information_encoded_value[MAX_USER_INFORMATION_LEN];
    ble_add_char_params_t add_user_information_params;
    memset(&add_user_information_params, 0, sizeof(add_user_information_params));
    
    add_user_information_params.uuid                = 0x2906;
    add_user_information_params.uuid_type           = ble_uuid.type; 
    add_user_information_params.max_len             = MAX_USER_INFORMATION_LEN;
    add_user_information_params.init_len            = user_information_encode(&user_information_initial_value, user_information_encoded_value);
    add_user_information_params.p_init_value        = user_information_encoded_value; 
    add_user_information_params.char_props.write    = 1; 
    add_user_information_params.write_access        = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_user_information_params.is_var_len          = 1; 

    err_code = characteristic_add(p_peggy_peripheral->service_handle, &add_user_information_params, &(p_peggy_peripheral->user_information_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    return NRF_SUCCESS;
}

/**@brief Function for sending the Coin Event Notification. */
uint32_t ble_peggy_peripheral_coin_event_notification_send(ble_peggy_peripheral_t * p_peggy_peripheral, ble_peggy_peripheral_coin_event_notification_t * p_coin_event_notification)
{
    uint32_t err_code = NRF_SUCCESS;

    if (p_peggy_peripheral->conn_handle != BLE_CONN_HANDLE_INVALID)
    {
        ble_gatts_hvx_params_t hvx_params;
        uint8_t encoded_value[MAX_COIN_EVENT_NOTIFICATION_LEN];
        uint16_t hvx_len;

        // Initialize value struct.
        memset(&hvx_params, 0, sizeof(hvx_params));

        hvx_len           = coin_event_notification_encode(p_coin_event_notification, encoded_value);
        hvx_params.handle = p_peggy_peripheral->coin_event_notification_handles.value_handle;
        hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;
        hvx_params.p_len  = &hvx_len;
        hvx_params.offset = 0;
        hvx_params.p_data = encoded_value;

        err_code = sd_ble_gatts_hvx(p_peggy_peripheral->conn_handle, &hvx_params);
    }
    else
    {
        err_code = NRF_ERROR_INVALID_STATE;
    }

    return err_code;
}

/**@brief Function for setting the Pending Transactions. */
uint32_t ble_peggy_peripheral_pending_transactions_set(ble_peggy_peripheral_t * p_peggy_peripheral, ble_peggy_peripheral_pending_transactions_t * p_pending_transactions)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_PENDING_TRANSACTIONS_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = pending_transactions_encode(p_pending_transactions, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_peggy_peripheral->conn_handle, p_peggy_peripheral->pending_transactions_handles.value_handle, &gatts_value);
}

/**@brief Function for sending the Pending Transactions Indicator. */
uint32_t ble_peggy_peripheral_pending_transactions_indicator_send(ble_peggy_peripheral_t * p_peggy_peripheral, ble_peggy_peripheral_pending_transactions_indicator_t * p_pending_transactions_indicator)
{
    uint32_t err_code = NRF_SUCCESS;

    if (p_peggy_peripheral->conn_handle != BLE_CONN_HANDLE_INVALID)
    {
        ble_gatts_hvx_params_t hvx_params;
        uint8_t encoded_value[MAX_PENDING_TRANSACTIONS_INDICATOR_LEN];
        uint16_t hvx_len;

        // Initialize value struct.
        memset(&hvx_params, 0, sizeof(hvx_params));

        hvx_len           = pending_transactions_indicator_encode(p_pending_transactions_indicator, encoded_value);
        hvx_params.handle = p_peggy_peripheral->pending_transactions_indicator_handles.value_handle;
        hvx_params.type   = BLE_GATT_HVX_INDICATION;
        hvx_params.p_len  = &hvx_len;
        hvx_params.offset = 0;
        hvx_params.p_data = encoded_value;

        err_code = sd_ble_gatts_hvx(p_peggy_peripheral->conn_handle, &hvx_params);
    }
    else
    {
        err_code = NRF_ERROR_INVALID_STATE;
    }

    return err_code;
}

/**@brief Function for setting the UUID. */
uint32_t ble_peggy_peripheral_uuid_set(ble_peggy_peripheral_t * p_peggy_peripheral, ble_peggy_peripheral_uuid_t * p_uuid)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_UUID_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = uuid_encode(p_uuid, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_peggy_peripheral->conn_handle, p_peggy_peripheral->uuid_handles.value_handle, &gatts_value);
}

